# Niveditha Bommanahally Parameshwarappa(nibomm), Dhruvil Mansukhbhai Dholariya(ddholari), Bindu Madhavi Dokala(bdokala)

# a1-release

### Part 1 : Fairies, heuristics, and A*

**Initial Code**:
The initial starter code was implemented using BFS algorithm. The algorithm was built using a Queue, and the heuristic function is not admissible as it is returning 0 in all cases. So, inorder to run the code fast, I am using A* solution instead of BFS and making the heuristic admissible h(s). 
* **State Space**:
The state space features five beautiful fairies arranged in a lovely line in a serene garden. Their magical job is to align their mystical symbols in harmony from 1 to N and reorganize themselves in ascending sequence from 1 to N (for example, 12345) in the fewest steps feasible. Each fairy may smoothly exchange places with only one of her nearby colleagues in one motion, producing a fascinating sight, with a wave of their wands. 
* **Cost Function**:
The cost is one for each step(swap of fairies) we make.
* **Start State**:
The parameter passed to the solve() function which is a list of numbers represting the arrangement of five fairies is the initial state. for example, [3,2,1,4,5] is the start state of the problem.
* **Goal State**:
Given the intial state of fairies, we rearrange the fairies in ascending order
from 1 to N (e.g., 32145 -> 12345) in as few steps as possible.
* **Successor Function**:
The successors are generated by checking how many possible moves we can make for each fairy. Given each fairy can switch places with only one of her neighboring companions in a single step. Each fairy can switch four possible positions with its neighboring companions. Hence, all the possible states switches generated for each fairy are called successors of that fairy.
* **Logic Implementation**:
Starting from initial state and considering it's cost as 0 and pushing the sum of initial states cost and its heuristic function result to a priority queue implemented through heapq. Iterating over the priority Queue until it is empty and popping the queue. if the current state is goal state we will return the path or else we will successors of each state, calculate f_cost and push it into the heapq.


### PART 2:The 2023 Puzzle

This Python code is a solver2023 for a 5x5 sliding tile puzzle, aiming to find a sequence of moves to reach the goal state from an initial state.using NumPy for array manipulate , heapq priority queue is used efficiency.

It employs the A* search algorithm with a priority queue to explore states efficiently, using a Manhattan distance heuristic to estimate the cost of reaching the goal state from the current state alone with length of moves taken to reached there. And we are using scaling factor of 0.2 in manhattan distance for optimisation as it should conisder the steps taken alone with it.

The code provides functions for generating successor states, applying moves, checking if a state is the goal, and includes a main block for reading the initial state from a file, solving the puzzle, and printing the solution and the number of moves required.

1. In this problem, what is the branching factor of the search tree?
   Possible moves (24 in total) are the branching factor in search tree
   moves_set = ["L5","L1","L2","L3","L4",
                 "R5","R1","R2","R3","R4",
                 "U5","U1","U2","U3","U4",
                 "D5","D1","D2","D3","D4",
                 "Oc","Occ","Ic","Icc"]

2. If the solution can be reached in 7 moves, about how many states would we need to explore before we found it if we 
used BFS instead of A* search? A rough answer is fine.
   In best case 7 and worst case ( 24 ^ 7 ) states needs to be searched in BFS for the given problem

### Part3 - Robust Transportation! 

To convert this problem into a search, we can treat each city as a node and if there are direct roads between cities, we can connect those two nodes with an edge and the weight of the edge depends on the type of cost function used. Then we can apply the A* search on the graph. 

* **State space**: All cities are valid states.
* **Successor function**: From each city, we can check in the dataset if there is a direct path, with some cost we can move to that city. 
* **Edge weights**:
   * For cost function 'segments': weight of an edge is 1 
   * For cost function 'distance': weight of an edge is the distance between two cities in miles
   * For cost function 'time': weight of an edge is the distance between two cities divided by the speed limit of that highway 
   * For cost function 'delivery': weight of edge is delivery time as defined in question *t<sub>road</sub> + p Â· 2(t<sub>road</sub> + t<sub>trip</sub>)*
* **Goal State**: Goal state is the destination city
* **Heuristic Function**: Used Euclidean Distance with a different multiplying factor for different cost functions. Multiplying factors are mentioned below:
   * segments: 1.2
   * distance: 20
   * time: 0.01
   * delivery: 0.01
* Multiplying factors are decided by trial and error such that the heuristic function is admissible, the output is optimal and the search becomes as fast as possible.


   
